/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/fileSystem/basic.ts":
/*!*********************************!*\
  !*** ./src/fileSystem/basic.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mkdir = exports.mkdirUnderDocument = void 0;
const photoshop_1 = __webpack_require__(/*! photoshop */ "photoshop");
const fs_1 = __importDefault(__webpack_require__(/*! fs */ "fs"));
const mkdirUnderDocument = (folderName, docPath) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const saveFolder = path.join(docPath, folderName);
        yield fs_1.default.mkdir(saveFolder);
        return saveFolder;
    }
    catch (e) {
        yield photoshop_1.app.showAlert(e);
        return false;
    }
});
exports.mkdirUnderDocument = mkdirUnderDocument;
const mkdir = (folderPath) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const f = yield fs_1.default.lstat(folderPath);
        return f.isDirectory();
    }
    catch (e) {
        yield fs_1.default.mkdir(folderPath); //if folder isn't exist, it'll generate
        return true;
    }
});
exports.mkdir = mkdir;


/***/ }),

/***/ "./src/fileSystem/root.ts":
/*!********************************!*\
  !*** ./src/fileSystem/root.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setProtocol = exports.DESKTOPPATH = void 0;
const os_1 = __importDefault(__webpack_require__(/*! os */ "os"));
exports.DESKTOPPATH = path.join(os_1.default.homedir(), 'Desktop');
//file protocol. you need this. using on older version than Photoshop 24.4 
const PROTOCOL = 'file:';
const setProtocol = filePath =>  true ? path.join(PROTOCOL, filePath) : 0;
exports.setProtocol = setProtocol;


/***/ }),

/***/ "./src/fileSystem/saveSystem.ts":
/*!**************************************!*\
  !*** ./src/fileSystem/saveSystem.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.writeTextFile = exports.registerDir = exports.mkdirWithPicker = exports.saveWithPicker = exports.saveOnDesktopAsImg = exports.saveOnDesktop = exports.saveActiveDocumentInFolder = exports.saveOnActiveDocumentDir = exports.saveJpeg = void 0;
const photoshop_1 = __webpack_require__(/*! photoshop */ "photoshop");
const fs_1 = __importDefault(__webpack_require__(/*! fs */ "fs"));
const uxp_1 = __importDefault(__webpack_require__(/*! uxp */ "uxp"));
const basic_1 = __webpack_require__(/*! ./basic */ "./src/fileSystem/basic.ts");
const root_1 = __webpack_require__(/*! ./root */ "./src/fileSystem/root.ts");
/*
some examples on document use uxp local filesystem module as a fs.
but it can be confused with fs module so use variable uxpfs instead of fs.
*/
const uxpfs = uxp_1.default.storage.localFileSystem;
// if you activate the code below(import path), you'll notice some path methods won't work. 
// import path from 'path'
/**
 * == Note ==
 *
 * since UXP updated to 6.4, It has Node.js style fileSystem.
 * but this is not same as Node.js, It's just like Node.js.
 * they have differences between them.
 * even if were web developer or enginner, I recommend to read the document carefully.
 *
 * you need require or import for using fs module.
 * but do not require or import path module.
 * path Object isn't module. this is a Window(global) object.
 * and UXP has uncomplited path module.
 * if you required it, you'll notice some methods won't be work.
 * because uncomplited path module takes over path object.
 *
 * on the document, path Object is classified as a Window object.
 * https://developer.adobe.com/photoshop/uxp/2022/uxp-api/reference-js/Global%20Members/Path
 *
 * on the other hand, fs is classified as a module.
 * https://developer.adobe.com/photoshop/uxp/2022/uxp-api/reference-js/Modules/fs
 *
 */
const whiteColor = new photoshop_1.app.SolidColor();
whiteColor.rgb.red = 255;
whiteColor.rgb.green = 255;
whiteColor.rgb.blue = 255;
/**
 * save document as a jpeg image in directory active document is saved.
 * @param param @type {JpegSaveOptionsParam}
 * @returns {Promise<boolean>}
 */
const saveJpeg = ({ filePath }) => {
    return new Promise((resolve, reject) => {
        filePath = (0, root_1.setProtocol)(filePath); // adding file Protocol following the global variable
        console.log(filePath);
        photoshop_1.core.executeAsModal(() => __awaiter(void 0, void 0, void 0, function* () {
            try {
                /* turn string path into Entry Object */
                const entrypath = yield uxpfs.getEntryWithUrl(filePath);
                console.log(entrypath);
                const option = {
                    quality: 12,
                    embedColorProfile: true,
                    color: whiteColor,
                };
                yield photoshop_1.app.activeDocument.saveAs.jpg(entrypath, option);
                resolve(true);
            }
            catch (e) {
                console.log(e);
                reject(e);
            }
        }), { commandName: 'saving jpeg image' });
    });
};
exports.saveJpeg = saveJpeg;
/**
 * @param param @type {JpegWIthEntryParam}
 * @returns {Promise<boolean>}
 */
const saveJpgWithEntry = ({ entry }) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
        photoshop_1.core.executeAsModal(() => __awaiter(void 0, void 0, void 0, function* () {
            try {
                const option = {
                    quality: 12,
                    embedColorProfile: true,
                    color: whiteColor,
                };
                yield photoshop_1.app.activeDocument.saveAs.jpg(entry, option);
                resolve(true);
            }
            catch (e) {
                console.log(e);
                reject(e);
            }
        }), { commandName: 'save jpeg' });
    });
});
/**
 * save image file on same directory where active document is saved.
 */
const saveOnActiveDocumentDir = () => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const flag = yield (0, exports.saveJpeg)({ filePath: photoshop_1.app.activeDocument.path });
        console.log(flag);
    }
    catch (e) {
        photoshop_1.app.showAlert(e);
    }
});
exports.saveOnActiveDocumentDir = saveOnActiveDocumentDir;
/**
 * create folder in same active document folder .
 * and save jpeg image in created folder.
 */
const saveActiveDocumentInFolder = () => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const folderName = 'jpeg';
        const folderPath = path.join(path.dirname(photoshop_1.app.activeDocument.path), folderName);
        yield (0, basic_1.mkdir)(folderPath); // create follder
        yield (0, exports.saveJpeg)({ filePath: folderPath });
    }
    catch (e) {
        photoshop_1.app.showAlert(e);
    }
});
exports.saveActiveDocumentInFolder = saveActiveDocumentInFolder;
/**
 * save document as jpeg image on desktop.
 * and keeping its file name
 */
const saveOnDesktop = () => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const flag = yield (0, exports.saveJpeg)({ filePath: root_1.DESKTOPPATH });
        console.log(flag);
    }
    catch (e) {
        photoshop_1.app.showAlert(e);
    }
});
exports.saveOnDesktop = saveOnDesktop;
/**
 * save image on desktop but as a different file name.
 */
const saveOnDesktopAsImg = () => __awaiter(void 0, void 0, void 0, function* () {
    try {
        let savePath = path.join(root_1.DESKTOPPATH, 'img.jpg');
        savePath = (0, root_1.setProtocol)(savePath);
        console.log(savePath);
        //uxpfs.createEntryWithUrl create Entry object from string file path.
        const flag = yield saveJpgWithEntry({ entry: yield uxpfs.createEntryWithUrl(savePath, { overwrite: true }) });
        console.log(flag);
    }
    catch (e) {
        photoshop_1.app.showAlert(e);
    }
});
exports.saveOnDesktopAsImg = saveOnDesktopAsImg;
/**
 * save jpg image with picker(dialog)
 */
const saveWithPicker = () => __awaiter(void 0, void 0, void 0, function* () {
    const entry = yield uxpfs.getFileForSaving('catimg.jpg', { types: ['jpg'] });
    console.log(entry);
    yield saveJpgWithEntry({ entry });
});
exports.saveWithPicker = saveWithPicker;
/**
 * make folder in directory you picked.
 */
const mkdirWithPicker = () => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const folderEntry = yield uxpfs.getFolder();
        console.log(folderEntry);
        const folerPath = (0, root_1.setProtocol)(folderEntry.nativePath);
        yield fs_1.default.mkdir(path.join(folerPath, 'newfolder'));
    }
    catch (e) {
        yield photoshop_1.app.showAlert(e);
    }
});
exports.mkdirWithPicker = mkdirWithPicker;
/**
 * register directory path on Panel.
 */
const registerDir = () => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const folderEntry = yield uxpfs.getFolder();
        document.getElementById('dir').textContent = folderEntry.nativePath;
    }
    catch (e) {
        yield photoshop_1.app.showAlert(e);
    }
});
exports.registerDir = registerDir;
/**
 * write text data in registered directory.
 */
const writeTextFile = () => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const dir = document.getElementById('dir').textContent;
        if (dir === '')
            throw new Error('no registered directory');
        const filePath = path.join((0, root_1.setProtocol)(dir), 'text');
        console.log(filePath);
        yield fs_1.default.writeFile(filePath, 'hello from photoshop');
        yield photoshop_1.app.showAlert('saved text file');
    }
    catch (e) {
        yield photoshop_1.app.showAlert(e);
    }
});
exports.writeTextFile = writeTextFile;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const photoshop_1 = __webpack_require__(/*! photoshop */ "photoshop");
const root_1 = __webpack_require__(/*! ./fileSystem/root */ "./src/fileSystem/root.ts");
const saveSystem_1 = __webpack_require__(/*! ./fileSystem/saveSystem */ "./src/fileSystem/saveSystem.ts");
const save_doc = document.getElementById('save_doc');
const save_folder = document.getElementById('save_folder');
const call_desktop = document.getElementById('call_desktop');
const save_desktop = document.getElementById('save_desktop');
const save_desktop_img = document.getElementById('save_desktop_img');
const save_picker = document.getElementById('save_picker');
const mkdir_picker = document.getElementById('mkdir_picker');
const register_directory = document.getElementById('register_directory');
const writeText = document.getElementById('writeText');
save_folder.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {
    yield (0, saveSystem_1.saveActiveDocumentInFolder)();
}));
call_desktop.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {
    yield photoshop_1.app.showAlert(root_1.DESKTOPPATH);
}));
save_doc.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {
    yield (0, saveSystem_1.saveOnActiveDocumentDir)();
}));
save_desktop.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {
    yield (0, saveSystem_1.saveOnDesktop)();
}));
save_desktop_img.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {
    yield (0, saveSystem_1.saveOnDesktopAsImg)();
}));
save_picker.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {
    yield (0, saveSystem_1.saveWithPicker)();
}));
mkdir_picker.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {
    yield (0, saveSystem_1.mkdirWithPicker)();
}));
register_directory.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {
    yield (0, saveSystem_1.registerDir)();
}));
writeText.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {
    yield (0, saveSystem_1.writeTextFile)();
}));


/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("os");

/***/ }),

/***/ "photoshop":
/*!****************************!*\
  !*** external "photoshop" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("photoshop");

/***/ }),

/***/ "uxp":
/*!**********************!*\
  !*** external "uxp" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("uxp");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=main.min.js.map